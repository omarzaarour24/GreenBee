-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.get_claim(
	uid uuid,
	claim text)
    RETURNS jsonb
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
    SET search_path=public
AS $BODY$

    DECLARE retval jsonb;
BEGIN
      IF NOT is_claims_admin() THEN
          RETURN '{"error":"access denied"}'::jsonb;
ELSE
select coalesce(raw_app_meta_data->claim, null) from auth.users into retval where id = uid::uuid;
return retval;
END IF;
END;
$BODY$;

ALTER FUNCTION public.get_claim(uuid, text)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_claim(uuid, text) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_claim(uuid, text) TO anon;

GRANT EXECUTE ON FUNCTION public.get_claim(uuid, text) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_claim(uuid, text) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_claim(uuid, text) TO service_role;

CREATE OR REPLACE FUNCTION public.get_my_claims(
	)
    RETURNS jsonb
    LANGUAGE 'sql'
    COST 100
    STABLE PARALLEL UNSAFE
AS $BODY$

select
    coalesce(nullif(current_setting('request.jwt.claims', true), '')::jsonb -> 'app_metadata', '{}'::jsonb)::jsonb
$BODY$;

ALTER FUNCTION public.get_my_claims()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_my_claims() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_my_claims() TO anon;

GRANT EXECUTE ON FUNCTION public.get_my_claims() TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_my_claims() TO postgres;

GRANT EXECUTE ON FUNCTION public.get_my_claims() TO service_role;

CREATE OR REPLACE FUNCTION public.get_my_claim(
	claim text)
    RETURNS jsonb
    LANGUAGE 'sql'
    COST 100
    STABLE PARALLEL UNSAFE
AS $BODY$

select
    coalesce(nullif(current_setting('request.jwt.claims', true), '')::jsonb -> 'app_metadata' -> claim, null)
        
$BODY$;

ALTER FUNCTION public.get_my_claim(text)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_my_claim(text) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_my_claim(text) TO anon;

GRANT EXECUTE ON FUNCTION public.get_my_claim(text) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_my_claim(text) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_my_claim(text) TO service_role;

CREATE OR REPLACE FUNCTION public.set_claim(
	uid uuid,
	claim text,
	value jsonb)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
    SET search_path=public
AS $BODY$

BEGIN
      IF NOT is_claims_admin() THEN
          RETURN 'error: access denied';
ELSE
update auth.users set raw_app_meta_data =
                              raw_app_meta_data ||
                              json_build_object(claim, value)::jsonb where id = uid;
return 'OK';
END IF;
END;
$BODY$;

ALTER FUNCTION public.set_claim(uuid, text, jsonb)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.set_claim(uuid, text, jsonb) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.set_claim(uuid, text, jsonb) TO anon;

GRANT EXECUTE ON FUNCTION public.set_claim(uuid, text, jsonb) TO authenticated;

GRANT EXECUTE ON FUNCTION public.set_claim(uuid, text, jsonb) TO postgres;

GRANT EXECUTE ON FUNCTION public.set_claim(uuid, text, jsonb) TO service_role;

CREATE OR REPLACE FUNCTION public.get_claims(
	uid uuid)
    RETURNS jsonb
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
    SET search_path=public
AS $BODY$

    DECLARE retval jsonb;
BEGIN
      IF NOT is_claims_admin() THEN
          RETURN '{"error":"access denied"}'::jsonb;
ELSE
select raw_app_meta_data from auth.users into retval where id = uid::uuid;
return retval;
END IF;
END;
$BODY$;

ALTER FUNCTION public.get_claims(uuid)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_claims(uuid) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_claims(uuid) TO anon;

GRANT EXECUTE ON FUNCTION public.get_claims(uuid) TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_claims(uuid) TO postgres;

GRANT EXECUTE ON FUNCTION public.get_claims(uuid) TO service_role;

CREATE OR REPLACE FUNCTION public.is_claims_admin(
	)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$

BEGIN
    IF session_user = 'authenticator' THEN
      --------------------------------------------
      -- To disallow any authenticated app users
      -- from editing claims, delete the following
      -- block of code and replace it with:
      -- RETURN FALSE;
      --------------------------------------------
      IF extract(epoch from now()) > coalesce((current_setting('request.jwt.claims', true)::jsonb)->>'exp', '0')::numeric THEN
        return false; -- jwt expired
END IF;
      IF coalesce((current_setting('request.jwt.claims', true)::jsonb)->'app_metadata'->'claims_admin', 'false')::bool THEN
        return true; -- user has claims_admin set to true
ELSE
        return false; -- user does NOT have claims_admin set to true
END IF;
      --------------------------------------------
      -- End of block
      --------------------------------------------
ELSE -- not a user session, probably being called from a trigger or something
      return true;
END IF;
END;
$BODY$;

ALTER FUNCTION public.is_claims_admin()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.is_claims_admin() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.is_claims_admin() TO anon;

GRANT EXECUTE ON FUNCTION public.is_claims_admin() TO authenticated;

GRANT EXECUTE ON FUNCTION public.is_claims_admin() TO postgres;

GRANT EXECUTE ON FUNCTION public.is_claims_admin() TO service_role;

CREATE OR REPLACE FUNCTION public.delete_claim(
	uid uuid,
	claim text)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
    SET search_path=public
AS $BODY$

BEGIN
      IF NOT is_claims_admin() THEN
          RETURN 'error: access denied';
ELSE
update auth.users set raw_app_meta_data =
                              raw_app_meta_data - claim where id = uid;
return 'OK';
END IF;
END;
$BODY$;

ALTER FUNCTION public.delete_claim(uuid, text)
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.delete_claim(uuid, text) TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.delete_claim(uuid, text) TO anon;

GRANT EXECUTE ON FUNCTION public.delete_claim(uuid, text) TO authenticated;

GRANT EXECUTE ON FUNCTION public.delete_claim(uuid, text) TO postgres;

GRANT EXECUTE ON FUNCTION public.delete_claim(uuid, text) TO service_role;

CREATE TABLE IF NOT EXISTS public.company
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    name text COLLATE pg_catalog."default" NOT NULL DEFAULT ''::text,
    email text COLLATE pg_catalog."default",
    phone_number bigint NOT NULL,
    address text COLLATE pg_catalog."default",
    CONSTRAINT company_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.company
    OWNER to postgres;

GRANT ALL ON TABLE public.company TO anon;

GRANT ALL ON TABLE public.company TO authenticated;

GRANT ALL ON TABLE public.company TO postgres;

GRANT ALL ON TABLE public.company TO service_role;

CREATE TABLE IF NOT EXISTS public.customer
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    name text COLLATE pg_catalog."default" NOT NULL,
    email text COLLATE pg_catalog."default",
    phone_number bigint NOT NULL,
    address text COLLATE pg_catalog."default",
    company_id bigint,
    CONSTRAINT customers_pkey PRIMARY KEY (id),
    CONSTRAINT customer_company_id_fkey FOREIGN KEY (company_id)
        REFERENCES public.company (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE SET NULL
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.customer
    OWNER to postgres;

GRANT ALL ON TABLE public.customer TO anon;

GRANT ALL ON TABLE public.customer TO authenticated;

GRANT ALL ON TABLE public.customer TO postgres;

GRANT ALL ON TABLE public.customer TO service_role;

CREATE TABLE IF NOT EXISTS public.converter
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    status text COLLATE pg_catalog."default",
    customer_id bigint,
    CONSTRAINT converter_pkey PRIMARY KEY (id),
    CONSTRAINT converter_customer_id_fkey FOREIGN KEY (customer_id)
        REFERENCES public.customer (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE SET NULL
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.converter
    OWNER to postgres;

GRANT ALL ON TABLE public.converter TO anon;

GRANT ALL ON TABLE public.converter TO authenticated;

GRANT ALL ON TABLE public.converter TO postgres;

GRANT ALL ON TABLE public.converter TO service_role;


CREATE TABLE IF NOT EXISTS public.ticket
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    customer bigint,
    status text COLLATE pg_catalog."default",
    note text COLLATE pg_catalog."default",
    date date,
    address text COLLATE pg_catalog."default",
    converter_id bigint,
    CONSTRAINT ticket_pkey PRIMARY KEY (id),
    CONSTRAINT ticket_converter_id_fkey FOREIGN KEY (converter_id)
        REFERENCES public.converter (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT ticket_customer_fkey FOREIGN KEY (customer)
        REFERENCES public.customer (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.ticket
    OWNER to postgres;

GRANT ALL ON TABLE public.ticket TO authenticated;

GRANT ALL ON TABLE public.ticket TO anon;

GRANT ALL ON TABLE public.ticket TO service_role;

GRANT ALL ON TABLE public.ticket TO postgres;

